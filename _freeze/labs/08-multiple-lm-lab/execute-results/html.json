{
  "hash": "83f1f7fd6c9982de01d5c94f0124a02c",
  "result": {
    "markdown": "---\ntitle: \"Lab 08: Multiple Linear Models\"\ndescription: |\n  (Stats) Learn how to interpret multiple linear models, make predictions, and use standard tests and diagnostics for evaluation, including making diagnostic plots. (R) Model summaries. Diagnostic plots. Prediction and plotting.\n---\n\n\n\n\n## Outline\n\n### Objectives\n\nThis lab will guide you through the process of  \n\n1. Creating multiple linear models\n2. Evaluating model assumptions with diagnostic plots\n2. Checking for correlation in the predictors\n    - Scatterplot matrix with `plot()`\n    - Pearson's Correlation with `cor()`\n    - Variance Inflation Factor with `vif()`\n\n### R Packages\n\nWe will be using the following packages:\n\n- [archdata](https://cran.r-project.org/web/packages/archdata/index.html)\n- [car](https://socialsciences.mcmaster.ca/jfox/Books/Companion/index.html)\n- [ISLR2](https://cran.r-project.org/web/packages/ISLR2/ISLR2.pdf)\n- [performance](https://easystats.github.io/performance/)\n- [skimr](https://docs.ropensci.org/skimr/)\n- [tidyverse](https://www.tidyverse.org/)\n\nYou'll want to install `ISLR2` and `car` with `install.packages(c(\"ISLR2\", \"car\"))`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(archdata)\nlibrary(car)\nlibrary(ISLR2)\nlibrary(performance)\nlibrary(skimr)\nlibrary(tidyverse)\n```\n:::\n\n    \n### Data\n\n- `adverts`\n    - Observations of product sales and investments in advertising across various media.\n    - package: none\n    - reference: <https://www.statlearning.com/resources-second-edition>\n- `Boston`\n    - A dataset containing housing values in 506 suburbs of Boston.\n    - package: `ISLR2`\n    - reference: <https://cran.r-project.org/web/packages/ISLR2/ISLR2.pdf>\n- `HandAxes`\n    - Includes measurements of handaxes from the Furze Platt site stored at the Royal Ontario Museum.\n    - package: `archdata`\n    - reference: <https://cran.r-project.org/web/packages/archdata/archdata.pdf>\n\n## Multiple Regression\n\nIn this section, we will walk through how to build a multiple linear model in R. This is not fundamentally different than building a simple linear model. The only difference is that we need to update the model formula. For the simple linear model, the formula is just y ~ x, for the multiple linear model, it‚Äôs y ~ x1 + x2 + ... + xn. We simply add the covariates together using the plus-sign. \n\nLet‚Äôs work through an example with the adverts data set used in the textbook [_An Introduction to Statistical Learning With Applications in R_](https://www.statlearning.com/). We want to know whether investment in different advertising media increases sales of some product. The website for the ISLR book hosts several data sets. The authors have also written companion R packages (ISLR and ISLR2, for the first and second editions, respectively). Now, as it happens, the path to a csv file does not have to be a local path pointing to a location on your computer. It can be also be a url pointing to where a file is stored remotely on a website, so reading in the advertising data from the ISLR website is as easy as this.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadverts <- read_csv(\"https://www.statlearning.com/s/Advertising.csv\") |> \n  rename_with(tolower) |> \n  select(sales, tv, radio, newspaper)\n```\n:::\n\n\nBefore fitting the model, let's have a look at some summaries of the data with `skim()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nskim(adverts)\n```\n\n::: {.cell-output-display}\nTable: Data summary\n\n|                         |        |\n|:------------------------|:-------|\n|Name                     |adverts |\n|Number of rows           |200     |\n|Number of columns        |4       |\n|_______________________  |        |\n|Column type frequency:   |        |\n|numeric                  |4       |\n|________________________ |        |\n|Group variables          |None    |\n\n\n**Variable type: numeric**\n\n|skim_variable | n_missing| complete_rate|  mean|    sd|  p0|   p25|   p50|   p75|  p100|hist  |\n|:-------------|---------:|-------------:|-----:|-----:|---:|-----:|-----:|-----:|-----:|:-----|\n|sales         |         0|             1|  14.0|  5.22| 1.6| 10.38|  12.9|  17.4|  27.0|‚ñÅ‚ñá‚ñá‚ñÖ‚ñÇ |\n|tv            |         0|             1| 147.0| 85.85| 0.7| 74.38| 149.8| 218.8| 296.4|‚ñá‚ñÜ‚ñÜ‚ñá‚ñÜ |\n|radio         |         0|             1|  23.3| 14.85| 0.0|  9.97|  22.9|  36.5|  49.6|‚ñá‚ñÜ‚ñÜ‚ñÜ‚ñÜ |\n|newspaper     |         0|             1|  30.6| 21.78| 0.3| 12.75|  25.8|  45.1| 114.0|‚ñá‚ñÜ‚ñÉ‚ñÅ‚ñÅ |\n:::\n:::\n\n\nAnd now the model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadverts_lm <- lm(sales ~ tv + radio + newspaper, data = adverts)\n\nsummary(adverts_lm)\n#> \n#> Call:\n#> lm(formula = sales ~ tv + radio + newspaper, data = adverts)\n#> \n#> Residuals:\n#>    Min     1Q Median     3Q    Max \n#> -8.828 -0.891  0.242  1.189  2.829 \n#> \n#> Coefficients:\n#>             Estimate Std. Error t value            Pr(>|t|)    \n#> (Intercept)  2.93889    0.31191    9.42 <0.0000000000000002 ***\n#> tv           0.04576    0.00139   32.81 <0.0000000000000002 ***\n#> radio        0.18853    0.00861   21.89 <0.0000000000000002 ***\n#> newspaper   -0.00104    0.00587   -0.18                0.86    \n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#> \n#> Residual standard error: 1.69 on 196 degrees of freedom\n#> Multiple R-squared:  0.897,\tAdjusted R-squared:  0.896 \n#> F-statistic:  570 on 3 and 196 DF,  p-value: <0.0000000000000002\n```\n:::\n\n\nNote the change in how we interpret the coefficients! Each coefficient must be interpreted relative to some value of the other covariates. For example, the coefficient estimate for television is 0.046. We interpret this as saying, \"For some given investment in radio and newspaper advertising, increasing tv advertising by $1000 will increase the number of units sold by approximately 46 units (because the units are measured in thousands, so 1000 x 0.046).\"\n\n### Exercises\n\n1. Load the `Boston` dataset from the `ISLR2` package with `data()`.\n2. Subset the variables in the dataset using the `select()` function from `dplyr`. Choose all the following variables: \n    - `medv` = median household value\n    - `rm` = number of rooms\n    - `crim` = per capita crime rate\n    - `lstat` = percent of households with low socioeconomic status\n2. Summarize the table with `skim()`.\n2. Make a simple linear model of median household value (`medv`) as a function of average number of rooms (`rm`).\n    - Call the model `simple_lm`.\n3. Now make a multiple linear model of median household value (`medv`) as a function of average number of rooms, per capita crime rate, and percent of household with low socioeconomic status (`rm`, `crim`, and `lstat`, respectively). \n    - Call the model `boston_lm`.\n4. Summarize the model with `summary()`.\n    - Are all the coefficients significantly different than zero?\n    - How much of the variance in house value is explained by these variables (ie what is the R-squared value)? \n5. How do you interpret the coefficient for number of rooms? What effect does increasing the number of rooms have?\n\n## Model Evaluation\n\nAs always, we can use the base `plot()` function to check model assumptions, using the `which` argument to specify the type of plot we want to make. For example, we can make a Q-Q plot like so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(adverts_lm, which = 2)\n```\n\n::: {.cell-output-display}\n![](08-multiple-lm-lab_files/figure-html/unnamed-chunk-6-1.png){width=480}\n:::\n:::\n\n\nOr, we can use the `check_model()` function from the `performance` package.\n\n\n::: {.cell fig.asp='1'}\n\n```{.r .cell-code}\ncheck_model(\n  adverts_lm,\n  check = c(\"linearity\", \"homogeneity\", \"outliers\", \"qq\")\n)\n```\n\n::: {.cell-output-display}\n![](08-multiple-lm-lab_files/figure-html/unnamed-chunk-7-1.png){width=100%}\n:::\n:::\n\n\nHow does it look? Have we met the assumptions of linear regression? Consider, for exmaple, that Q-Q plot. It would seem to suggest that the residuals are skewed to the left. That's not good because the linear model assumes that the residuals are normally distributed and centered on zero. Another way to check for this is to plot a histogram of the residuals and check whether it has the shape of a bell curve.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadverts_residuals <- tibble(residuals = residuals(adverts_lm))\n\nggplot(adverts_residuals, aes(residuals)) +\n  geom_histogram() +\n  labs(\n    x = \"Residual Sales\",\n    y = \"Count\"\n  )\n```\n\n::: {.cell-output-display}\n![](08-multiple-lm-lab_files/figure-html/unnamed-chunk-8-1.png){width=480}\n:::\n:::\n\n\nüò¨ You can see the left skew as indicated by the Q-Q plot. \n\n### Exercises\n\n1. Plot a histogram of the residuals in `boston_lm`.\n    - Use `residuals()` to get the residuals out of the model object.\n    - Use `geom_histogram()`.\n1. Run `check_model()` on `boston_lm` and check for linearity, homogeneity, outliers, and qq. \n2. Does the model meet the assumptions of linear regression?\n\n## ANOVA\n\nWhen evaluating the model, we should also check whether adding variables actually makes a significant improvement. To do that, we need to compare the complex model to a simpler model. In R, we do that with the `anova()` function. Here, we're going to compare the full model to set of simpler models that are nested within it. Note that in each case the simpler model is a subset of the more complex model (ie, these are nested models)! The ANOVA wouldn't work otherwise! \n\n\n::: {.cell}\n\n```{.r .cell-code}\nm1 <- lm(sales ~ tv, data = adverts)\nm2 <- lm(sales ~ tv + radio, data = adverts)\nm3 <- lm(sales ~ tv + radio + newspaper, data = adverts)\n\nanova(m1, m2, m3)\n#> Analysis of Variance Table\n#> \n#> Model 1: sales ~ tv\n#> Model 2: sales ~ tv + radio\n#> Model 3: sales ~ tv + radio + newspaper\n#>   Res.Df  RSS Df Sum of Sq      F              Pr(>F)    \n#> 1    198 2103                                            \n#> 2    197  557  1      1546 544.05 <0.0000000000000002 ***\n#> 3    196  557  1         0   0.03                0.86    \n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n\n\nThis is a sequential ANOVA that does comparisons in order, first comparing the `tv` model to the intercept model, then the `tv + radio` model to the `tv` model, and so on, to the full model. For each step, it reports the residual sum of squares (`RSS` or the error in the model) and evaluates whether the difference in that value between the models is significant. The degrees of freedom (`DF`) represents the difference in residual degrees of freedom (`Res.Df`) between the simple and complex models (for row 2, that's 199-198=1). The sum of squares (`Sum of Sq`) is the difference in the Residual Sum of Squares (`RSS`) for each model (for row 2, that's 5417-2103=3315). The `F` statistic is then the ratio of (Sum of Sq/Df) to what is effectively the mean squared error of the full model (for row 2 that's (3315/5)/(557/196) = 1166). The intuitive idea here is that an F-statistic close to zero means that adding the covariate does not reduce the model's RSS or error to any meaningful degree. As always, the F-statistic is then compared to an F distribution with the degrees of freedom to determine how likely that particular value is, assuming the null hypothesis that there is no significant improvement. Notice that each of these covariates makes a significant contribution to the model of sales except newspaper spending. Why might that be?\n\nOne last point, before moving on. You do not have to explicitly generate a sequence of nested models. You can simply call `anova()` on the full model and it will generate those models for you. However, do be aware that the printed ANOVA table is slightly different (additional columns and different column names) in the two cases. Here it is the for the full advertising model:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanova(adverts_lm)\n#> Analysis of Variance Table\n#> \n#> Response: sales\n#>            Df Sum Sq Mean Sq F value              Pr(>F)    \n#> tv          1   3315    3315 1166.73 <0.0000000000000002 ***\n#> radio       1   1546    1546  544.05 <0.0000000000000002 ***\n#> newspaper   1      0       0    0.03                0.86    \n#> Residuals 196    557       3                                \n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n\n\n### Exercises\n\n1. Use the `anova()` function to compare `simple_lm` to `boston_lm`.\n    - State your null and alternate hypotheses.\n2. Is the complex model worth it?\n\n## Collinearity\n\nLinear regression assumes that the predictor or independent variables are uncorrelated. However, this is often not the case. To evaluate this assumption, you can do one of two things. I actually recommend that you always do both. First, you can check for pairwise correlations visually with the `pairs()` function from base R or analytically with the `cor()` argument. Both work with tables. Second, you check for multicollinearity using the `vif()` function to estimate the Variance Inflation Factor for each covariate.\n\n### Check for collinearity\n\n\n::: {.cell}\n\n```{.r .cell-code}\npairs(adverts)\n```\n\n::: {.cell-output-display}\n![](08-multiple-lm-lab_files/figure-html/unnamed-chunk-11-1.png){width=480}\n:::\n\n```{.r .cell-code}\ncor(adverts)\n#>           sales     tv  radio newspaper\n#> sales     1.000 0.7822 0.5762    0.2283\n#> tv        0.782 1.0000 0.0548    0.0566\n#> radio     0.576 0.0548 1.0000    0.3541\n#> newspaper 0.228 0.0566 0.3541    1.0000\n```\n:::\n\n\nNotice that `pairs()` generates a scatterplot matrix with all pairwise combination of variables. If there's no correlation, the scatterplot should look like a cloud of random points. If there is a correlation, the points will cluster along some line. The `cor()` function generates a correlation matrix (by default a Pearson's correlation matrix). Of course, every variable correlates perfectly with itself, hence a value of 1 along the diagonal. Values above and below the diagonal are simply mirrors of each other, as is the case with the scatterplot matrix. The fact that each variable correlates with sales is not problematic in this case, as that is the relationship we are trying to model. What we want to focus on here is the degree of correlation between the predictors `tv`, `radio`, and `newspaper`. It is preferable that the correlations between these be as close to zero as possible, but again, it will rarely be the case that they are exactly zero. Any value greater than 0.7 is a cause for concern and should lead you to update your model to address it.\n\n### Check for multicollinearity\n\nGenerally, it's a good idea to test for correlations between predictors before building a model. However, the `vif()` function only works on model objects, which makes sense as the variance being inflated is variance around coefficient estimates made by the model. That means, of course, that you have to build a model first before evaluating its covariates for multicollinearity. Using the linear model we made with the advertising data, that looks like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvif(adverts_lm)\n#>        tv     radio newspaper \n#>      1.00      1.14      1.15\n```\n:::\n\n\nThis generates a named vector, with one value for each covariate. A general rule of thumb is that VIF for a coefficient should be less than 5. After that, you should consider changes to your model.\n\n### Exercises\n\n1. Use `pairs()` on the `Boston` data to visualize pairwise relationships between variables.\n    - Do you see any potential trends?\n2. Use `cor()` on the `Boston` data to estimate the Pearson correlation coefficient for each pair of variables.\n    - Are there any strong correlations?\n3. Use `vif()` on the `bostom_lm` model to estimate the Variance Inflation Factor for each covariate.\n    - Are any greater than 5 for any of them?\n\n## Homework\n\n1. Load the `Handaxes` dataset from the `archdata` package using `data()`.\n2. Now let's explore this dataset.\n    - Check the variables that it includes with `names()`. You should see maximum length (`L`), breadth (`B`), and thickness (`T`), among others.\n    - Try renaming those to make them more informative and readable with `rename()`.\n    - Use `select()` to subset this table, taking only those three variables (length, breadth, and thickness).\n    - Summarize this table with `skim()`.\n    - Visualize the pairwise relationships between variables with `pairs()`.\n    - Estimate Pearson's correlation coefficient for each pair of variables with `cor()`.\n2. Now making a simple linear model showing the relationship (if any) between the length and breadth of handaxes. Be sure to do all of the following:\n    - Use `summary()` to report the model. \n    - Use `predict()` and `geom_line()` to visualize the modeled relationship. Be sure to plot this over the data!\n    - Add a confidence interval with `geom_ribbon()`.\n    - Use `check_model()` to visually inspect the model.\n    - Does the model satisfy the assumptions of linear regression?\n2. Build a multiple linear model of handaxe length as a function of breadth and thickness. Be sure to do all of the following:\n    - Use `summary()` to report the model. \n    - Use `check_model()` to visually inspect the model.\n    - Does the model satisfy the assumptions of linear regression?\n2. Use the `vif()` function on the multiple linear model.\n    - Is the VIF for either variable greater than 5?\n2. Conduct an ANOVA using the `anova()` function to compare the simple and complex models.\n    - Does the complex model significantly improve on the simpler model?",
    "supporting": [
      "08-multiple-lm-lab_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}